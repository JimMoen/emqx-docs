# Ingest MQTT Data into MongoDB

{% emqxce %}
:::tip
EMQX Enterprise Edition features. EMQX Enterprise Edition provides comprehensive coverage of key business scenarios, rich data integration, product-level reliability, and 24/7 global technical support. Experience the benefits of this [enterprise-ready MQTT messaging platform](https://www.emqx.com/en/try?product=enterprise) today.
:::
{% endemqxce %}

MongoDB, a leading NoSQL database, is renowned for its flexibility in schema design, scalability, and capacity to store large volumes of structured and semi-structured data. By integrating EMQX with MongoDB, users can efficiently ingest MQTT messages and client events directly into MongoDB. This facilitates long-term series data storage and advanced querying capabilities within MongoDB. The integration ensures a single-directional flow, where MQTT messages from EMQX are written into the MongoDB database. This powerful combination serves as a solid foundation for businesses looking to manage their IoT data effectively.

## How It Works

The integration of EMQX with MongoDB is rooted in the EMQX rule engine. This rule engine acts as an intermediary, directing the flow of MQTT messages from connected devices to the MongoDB bridge, and it achieves this with without the need for any advanced coding.

1. **Data Collection**: Devices, whether they are part of connected vehicles, IIoT systems, or energy management platforms, send MQTT messages based on their operational states, readings, or triggered events.
2. **EMQX Rule Engine**: These messages are then processed by the EMQX rule engine rules. The rules, based on predefined criteria, determines which messages need to be routed to MongoDB. The beauty of this step is its simplicity; users can define their criteria without delving into any complex coding.
3. **Data Ingestion into MongoDB**: Once the rule engine identifies a message for MongoDB storage, it channels that message seamlessly into the MongoDB bridge that forwards it to the database.
4. **Data Storage and Utilization**: With the data now stored in MongoDB, businesses can harness its querying power for various use-cases. For instance, in the realm of connected vehicles, this stored data can inform fleet management systems about vehicle health, optimize route planning based on real-time metrics, or track assets. Similarly, in IIoT settings, the data might be used to monitor machinery health, forecast maintenance, or optimize production schedules.

By using this integrated system, businesses in sectors like power and energy can continuously monitor grid health, forecast demand, or identify potential outages before they happen. The value derived from the real-time and historical data not only ensures operational efficiency but can also lead to significant cost savings and enhanced customer experiences.

## Features and Benefits

The data integration with MongoDB offers a range of features and benefits tailored to ensure effective data handling and storage:

1. **Dedicated Egress Traffic Support**: The MongoDB bridge is designed for egress traffic, which ensures seamless and uninterrupted data flow from MQTT messages in EMQX directly to a MongoDB instance.
2. **Flexible MongoDB Connection Options**: Whether you operate with a single MongoDB instance or leverage the robustness of a replica set, the bridge offers native support to connect with both configurations, providing businesses with the flexibility to adapt as per their infrastructure needs.
3. **NoSQL**: MongoDB's schema-less architecture ensures that diverse MQTT message structures can be easily stored without the need for rigid schemas, accommodating the dynamic nature of IoT data.
4. **Scalability and Performance**: Given MongoDB's inherent scalability, integrating it with EMQX ensures that as your IoT deployments grow, your data storage capabilities can scale with ease, handling vast amounts of data generated from myriad devices.
5. **Reliable Data Storage**: Once the EMQX rule engine processes and routes the message, it is stored in MongoDB with the platform's proven reliability, ensuring data integrity and consistent availability.
6. **Operational Metrics**: Glean insights from metrics such as the total message count, egress traffic rate, and more. These metrics, combined with MongoDB's powerful querying, can be utilized to monitor, analyze, and optimize the data flow.
7. **Latest MongoDB Version Support**: The bridge is compatible with and supports the latest versions of MongoDB, ensuring users benefit from the newest features, optimizations, and security updates offered by the database platform.

This MongoDB integration fortifies your IoT infrastructure, ensuring that vast amounts of data generated by your devices are not just stored but are also ready for future querying and analysis. The ease of setup and operational excellence it brings can greatly enhance the efficiency and reliability of your IoT systems.

## Befor You Start

This section describe the preparations you need to complete before you start to create the MongoDB data bridges in EMQX Dashboard.

### Prerequisites

- Knowledge about EMQX data integration [rules](./rules.md)
- Knowledge about [data bridge](./data-bridges.md)
- Knowledge about [MongoDB](https://www.mongodb.com/)

### Install MongoDB Server

Install MongoDB via Docker, and then run the docker image. 

```
#  To start the MongoDB docker image and set the password as public
docker run -d --name mongodb -p 27017:27017 mongo

# Access the container
docker exec -it mongodb bash

# Locate the MongoDB server in the container
mongo

# Create a user
use admin
db.createUser({ user: "admin", pwd: "public", roles: [ { role: "root", db: "admin" } ] })

```

### Create a Database

You can use the following command to create a database in MongDB:

```
# Create database emqx_data
use emqx_data

# create collection emqx_messages
db.createCollection('emqx_messages')
```

## Create Rule and MongoDB Data Bridge

1. Go to EMQX Dashboard, click **Integration** -> **Rules**.

2. Click **Create** on the top right corner of the page.

3. Input `my_rule` as the rule ID, and set the rules in the **SQL Editor**. Here we want to save the MQTT messages under topic `t/#`  to MongoDB, we can use the SQL syntax below. 

   Note: If you want to specify your own SQL syntax, make sure that you have included all fields required by the data bridge in the `SELECT` part.

```
SELECT
  *
FROM
  "t/#"
```

You can use the SQL syntax below to save `timestamp` as data type and the `payload`  in JSON as JSON strings:

```
SELECT
  *,
  mongo_date(timestamp) as timestamp,
  json_encode(payload) as payload
FROM
  "t/#"
```

Note: If you are a beginner user, you can click **SQL Examples** and **Enable Test** to learn and test the SQL rule. 

4. Click the + **Add Action** button to define an action that will be triggered by the rule. Select **Forwarding with Data Bridge** from the dropdown list. With this action, EMQX sends the data processed by the rule to MongoDB.
5. Click the **+** icon next to the **Data bridge** drop-down box to create a data bridge.
6. Select **MongoDB** from the **Type of Data Bridge** drop-down list. Fill in the required fields (marked with an asterisk).
7. Enter a name for the data bridge. The name should be a combination of upper/lower case letters and numbers.
8. Set **MongoDB Mode**  and **Srv Record** as your business needs, for example, **single** and the default deselected status.
9. Configure the MongoDB connection information. Input `emqx_data` as the **Database Name**, `127.0.0.1:27017` as the **Server Host**, `admin` as the **Username**, `public` as the **Password**, and `emqx_messages` as **Collection to be used**. For the other fields, you can keep the default setting. 
10. Configure the **Payload template** to save `clientid`, `topic`, `qos`,  `timestamp`, and `payload` to MongoDB. This template will be executed via the MongoDB insert command, and the sample code is as follows:

```json
{
  "clientid": "${clientid}",
  "topic": "${topic}",
  "qos": ${qos},
  "timestamp": ${timestamp},
  "payload": ${payload}
}
```

::: tip Notes when configuring the Payload template:

- All `keys` need to be wrapped in double quotes `"`;
- Auto-derivation of the data type of "value" is not supported:
  - Characters need to be wrapped with `"`, otherwise, an error will be reported;
  - Values do not need to be wrapped, otherwise, they will be recognized as characters;
  - For timestamp, date, and time types, if no special treatment is performed, they will be recognized as numeric or character types. To store them as date or time, use the `mongo_date` function in the rule SQL to process the fields. For details, see [Time and date functions](./rule-sql-builtin-functions.md#time-and-date-functions). 

- Nested objects are allowed, when value is a JSON object:
  - It is not allowed to use `"` to nest the value in the template, otherwise, it will cause an execution error;
  - Objects will be nested and stored according to their own structure;

- To store objects as JSON characters, use the `json_encode` function in rule SQL for the conversion, and the corresponding **value** in the template is still not allowed to be wrapped with `"`. 

:::

11. Advanced settings (optional): See [Advanced Configurations](#advanced-configurations).

12. Before clicking **Create**, you can click **Test Connectivity** to test that the bridge can connect to the MongoDB server.

13. Click the **Create** button to finish the setup.

Now the MongoDB data bridge should appear in the data bridge list (**Integration** -> **Data Bridge**) with **Resource Status** as **Connected**.

## Test MongoDB Data Bridge and Rule

Use MQTTX  to send a message to topic  `t/1`:

```
mqttx pub -i emqx_c -t t/1 -m '{ "msg": "hello MongoDB" }'
```

Check the running status of the two data bridges, there should be one new **Matched** and one new **Sent Successfully** message.

Check whether the message is written into collection `emqx_messages`:

```
> db.emqx_messages.find().pretty()
{
    "_id" : ObjectId("63db7059df489d01ed000009"),
    "clientid" : "emqx_c",
    "payload" : {
      "msg" : "hello MongoDB"
    },
    "qos" : 0,
    "timestamp" : NumberLong("1675325529070"),
    "topic" : "t/1"
}
```

Under the second rule SQL, the returned information should be: 

```
> db.emqx_messages.find().pretty()
{
    "_id" : ObjectId("63db7535df489d01ed000013"),
    "clientid" : "emqx_c",
    "payload" : "{ \"msg\": \"hello MongoDB\" }",
    "qos" : 0,
    "timestamp" : ISODate("2023-02-02T08:33:36.715Z"),
    "topic" : "t/1"
}
```

## Advanced Configurations

This section delves deeper into the advanced configuration options available for the EMQX MongoDB Bridge. When configuring the data bridge, navigate to **Advanced Settings** to tailor the following parameters to meet your specific needs.

| **Fields**                   | **Descriptions**                                                                                                                                                                                                                                                                                                                                                            | **Recommended Value** |
|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------|
| **Connect Timeout**          | The time duration EMQX will wait while attempting to establish a connection to MongoDB before timing out.                                                                                                                                                                                                                                                                   | 30s                   |
| **Socket Timeout**           | This determines how long EMQX will wait while trying to send or receive data on a socket connection with MongoDB before it times out.                                                                                                                                                                                                                                       | 30s                   |
| **Max Overflow Workers**     | Specifies the additional number of workers that can be created when all existing workers are occupied. This setting is crucial in times of workload surges to permit more concurrent connections to MongoDB.                                                                                                                                                                | 0                     |
| **Wait Queue Timeout**       | The maximum duration a worker can remain idle while waiting for a connection to MongoDB to become available.                                                                                                                                                                                                                                                                | 10s                   |
| **Heartbeat Period**         | Defines the interval at which the driver checks the state of the MongoDB deployment. This specifies the time between consecutive checks, effectively controlling the frequency of these heartbeat signals to ensure MongoDB's operational status.                                                                                                                           | 200s                  |
| **Minimum Heartbeat Period** | Sets the shortest time interval allowed between heartbeats, ensuring that the driver doesn't check the MongoDB state too frequently. This is vital for avoiding unnecessary loads and ensuring efficient communication between EMQX and MongoDB.                                                                                                                            | 200s                  |
| **Use Legacy Protocol**      | Determines if MongoDB's legacy communication protocol should be used. MongoDB introduced a new wire protocol in version 3.6, with the legacy protocol retained for backward compatibility. This setting can be set to true, false, or auto. In "auto" mode (default option), EMQX will automatically determine which protocol to use based on the detected MongoDB version. | auto                  |




## More Information

Check out the following links to learn more:

**Blogs:**
https://www.emqx.com/en/blog/emqx-rule-engine-series-store-messages-to-the-mongodb-database

**Videos:**

https://www.youtube.com/watch?v=c2M-rlkkT5o
